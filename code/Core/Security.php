<?php
namespace Core;

/**
 * Class Security
 * @package Core
 
 * @source-by Phalcon
 */
class Security {

    /**
     * Work Factor
     *
     * @var int
     */
    protected $_workFactor = 8;

    /**
     * Number of Bytes
     *
     * @var int
     */
    protected $_numberBytes = 16;

    /**
     * CSRF
     *
     * @var null
     */
    protected $_csrf;

    /**
     *
     *
     * @return Session
     */
    public function getSession() {
        return Di::get('session');
    }

    /**
     *
     *
     * @return Request
     */
    public function getRequest() {
        return Di::get('request');
    }

    /**
     * Sets a number of bytes to be generated by the openssl pseudo random generator
     *
     * @param int $randomBytes
     * @throws \Exception
     */
    public function setRandomBytes($randomBytes) {
        if (is_int($randomBytes) === false) {
            throw new \Exception('Invalid parameter type.');
        }
        if (count($randomBytes) < 16) {
            throw new \Exception('At least 16 bytes are needed to produce a correct salt');
        }
        $this->_numberBytes = $randomBytes;
    }

    /**
     * Returns a number of bytes to be generated by the openssl pseudo random generator
     *
     * @return int
     */
    public function getRandomBytes() {
        return $this->_numberBytes;
    }

    /**
     * Sets the default working factor for bcrypts password's salts
     *
     * @param int $workFactor
     * @throws \Exception
     */
    public function setWorkFactor($workFactor) {
        if (is_int($workFactor) === false) {
            throw new \Exception('Invalid parameter type.');
        }
        $this->_workFactor = $workFactor;
    }

    /**
     * Returns the default working factor for bcrypts password's salts
     *
     * @return int
     */
    public function getWorkFactor() {
        return $this->_workFactor;
    }

    /**
     * Alphanumerical Validator
     *
     * @param string $value
     * @return string
     */
    private static function validatorAlnum($value) {
        $valid = '';
        $value = (string)$value;
        $valueLength = strlen($value);
        $zeroChar = chr(0);
        for ($i = 0; $i < $valueLength; ++$i) {
            if ($value[$i] == $zeroChar) {
                break;
            }
            if (ctype_alnum($value[$i]) === true) {
                $valid .= $value[$i];
            }
        }
        return $valid;
    }

    /**
     * Generate a >22-length pseudo random string to be used as salt for passwords
     *
     * @return string
     * @throws \Exception
     */
    public function getSaltBytes() {
        if (function_exists('openssl_random_pseudo_bytes') === false) {
            throw new \Exception('Openssl extension must be loaded');
        }
        $safeBytes = '';
        while (strlen($safeBytes) < 22) {
            $randomBytes = openssl_random_pseudo_bytes($this->_numberBytes);
            //@note added check
            if ($randomBytes === false) {
                throw new \Exception('Error while generating random bytes.');
            }
            $base64bytes = base64_encode($randomBytes);
            $safeBytes = self::validatorAlnum($base64bytes);
            if (empty($safeBytes) === true) {
                continue;
            }
        }
        return $safeBytes;
    }

    /**
     * Creates a password hash using bcrypt with a pseudo random salt
     *
     * @param string $password
     * @param int|null $workFactor
     * @return string
     * @throws \Exception
     */
    public function hash($password, $workFactor = null) {
        if (is_string($password) === false) {
            throw new \Exception('Invalid parameter type.');
        }
        if (is_null($workFactor) === true) {
            $workFactor = $this->_workFactor;
        } elseif (is_int($workFactor) === false) {
            throw new \Exception('Invalid parameter type.');
        }
        $factor = sprintf('%02s', $workFactor);
        $saltBytes = $this->getSaltBytes();
        $salt = '$2a$'.$factor.'$'.$saltBytes;
        return crypt($password, $salt);
    }

    /**
     * Checks a plain text password and its hash version to check if the password matches
     *
     * @param string $password
     * @param string $passwordHash
     * @param int|null $maxPasswordLength
     * @return boolean
     * @throws \Exception
     */
    public function checkHash($password, $passwordHash, $maxPasswordLength = null) {
        /* Type check */
        if (is_string($password) === false ||
            is_string($passwordHash) === false) {
            throw new \Exception('Invalid parameter type.');
        }
        if (is_int($maxPasswordLength) === true) {
            if ($maxPasswordLength > 0 && strlen($password) > $maxPasswordLength) {
                return false;
            }
        } elseif (is_null($maxPasswordLength) === false) {
            throw new \Exception('Invalid parameter type.');
        }
        /* Hash */
        try {
            $hash = crypt($password, $passwordHash);
        } catch (\Exception $e) {
            return false;
        }
        if (is_string($hash) === false) {
            $hash = (string)$hash;
        }
        if (strlen($hash) === strlen($passwordHash)) {
            $n = strlen($hash);
            $check = false;
            for ($i = 0; $i < $n; ++$i) {
                $check |= (ord($hash[$i])) ^ (ord($passwordHash[$i]));
            }
            return (bool)($check === 0 ? true : false);
        }
        return false;
    }

    /**
     * Checks if a password hash is a valid bcrypt's hash
     *
     * @param string $passwordHash
     * @return boolean
     * @throws \Exception
     */
    public function isLegacyHash($passwordHash) {
        if (is_string($passwordHash) === false) {
            throw new \Exception('Invalid parameter type.');
        }
        return (strpos($passwordHash, '$2a$') === 0);
    }

    /**
     * Generates a pseudo random token key to be used as input's name in a CSRF check
     *
     * @param int|null $numberBytes
     * @return string
     * @throws \Exception
     */
    public function getTokenKey($numberBytes = null) {
        if (is_null($numberBytes) === true) {
            $numberBytes = 12;
        } elseif (is_int($numberBytes) === false) {
            throw new \Exception('Invalid parameter type.');
        }
        if (function_exists('openssl_random_pseudo_bytes') === false) {
            throw new \Exception('Openssl extension must be loaded');
        }
        if ($this->getSession()->has('CSRF-KEY')) {
            return $this->getSession()->get('CSRF-KEY');
        }
        $randomBytes = openssl_random_pseudo_bytes($numberBytes);
        $base64bytes = base64_encode($randomBytes);
        $safeBytes = self::validatorAlnum($base64bytes);
        //@warning no length check for $safeBytes

        $this->getSession()->set('CSRF-KEY', $safeBytes);
        return $safeBytes;
    }

    /**
     * Generates a pseudo random token value to be used as input's value in a CSRF check
     *
     * @param int|null $numberBytes
     * @return string
     * @throws \Exception
     */
    public function getToken($numberBytes = null) {
        if (is_null($numberBytes) === true) {
            $numberBytes = 12;
        } elseif (is_int($numberBytes) === false) {
            throw new \Exception('Invalid parameter type.');
        }
        if (function_exists('openssl_random_pseudo_bytes') === false) {
            throw new \Exception('Openssl extension must be loaded');
        }
        if ($this->getSession()->has('CSRF-TOKEN')) {
            return $this->getSession()->get('CSRF-TOKEN');
        }
        $randomBytes = openssl_random_pseudo_bytes($numberBytes);
        //@note MD5 is weak
        $token = md5($randomBytes);
        $this->getSession()->set('CSRF-TOKEN', $token);
        return $token;
    }

    /**
     * Check if the CSRF token sent in the request is the same that the current in session
     *
     * @param string|null $tokenKey
     * @param string|null $tokenValue
     * @return boolean
     * @throws \Exception
     */
    public function checkToken($tokenKey = null, $tokenValue = null) {
        /* Type check */
        if (is_null($tokenKey) === false && is_string($tokenKey) === false) {
            throw new \Exception('Invalid parameter type.');
        }
        if (is_null($tokenValue) === false && is_string($tokenValue) === false) {
            throw new \Exception('Invalid parameter type.');
        }
        /* Get token data */
        if (is_null($tokenKey) === true) {
            $tokenKey = $this->getSession()->get('CSRF-KEY');
        }
        if (is_null($tokenValue) === true) {
            //We always check if the value is correct in post
            $tokenValue = $this->getRequest()->post($tokenKey);
        }
        $sessionToken = $this->getSession()->get('CSRF-TOKEN');
        //The value is the same?
        return ($tokenValue === $sessionToken ? true : false);
    }

    /**
     * Returns the value of the CSRF token in session
     *
     * @return string
     * @throws \Exception
     */
    public function getSessionToken() {
        return $this->getSession()->get('CSRF-TOKEN');
    }
}